---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - frontend/src/lib/api-client.ts
  - frontend/src/lib/query-client.ts
  - frontend/src/types/api.ts
  - frontend/src/App.tsx
  - frontend/.env.example
  - frontend/.env.local
  - frontend/.gitignore
autonomous: true

must_haves:
  truths:
    - "API client can make typed requests to the FastAPI backend"
    - "API errors are normalized into ApiError class with status and detail"
    - "TanStack Query provider wraps the application"
    - "Query DevTools are available in development mode"
    - "Environment variable VITE_API_URL configures the API base URL"
  artifacts:
    - path: "frontend/src/lib/api-client.ts"
      provides: "Typed fetch wrapper with error handling"
      exports: ["apiClient", "ApiError"]
    - path: "frontend/src/lib/query-client.ts"
      provides: "TanStack Query client configuration"
      exports: ["queryClient"]
    - path: "frontend/src/types/api.ts"
      provides: "TypeScript types matching backend schemas"
      contains: "ChatRequest"
  key_links:
    - from: "frontend/src/App.tsx"
      to: "frontend/src/lib/query-client.ts"
      via: "QueryClientProvider"
      pattern: "QueryClientProvider.*client.*queryClient"
    - from: "frontend/src/lib/api-client.ts"
      to: "VITE_API_URL"
      via: "import.meta.env"
      pattern: "import\\.meta\\.env\\.VITE_API_URL"
---

<objective>
Configure API client with typed fetch wrapper and TanStack Query for server state management

Purpose: Establish the data fetching infrastructure that all feature phases will use. The typed API client ensures consistent error handling and type safety, while TanStack Query provides caching, background refetching, and loading state management.

Output: Working API client with ApiError class, TanStack Query configured with DevTools, and TypeScript types matching the FastAPI backend schemas.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@src/posts/schemas.py
@src/sessions/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typed API client with error handling</name>
  <files>
    frontend/src/lib/api-client.ts
    frontend/.env.example
    frontend/.env.local
    frontend/.gitignore
  </files>
  <action>
    Create the base API client infrastructure:

    1. Create frontend/.env.example (committed to git):
       ```
       # API Configuration
       VITE_API_URL=http://localhost:8000
       ```

    2. Create frontend/.env.local (gitignored):
       ```
       VITE_API_URL=http://localhost:8000
       ```

    3. Update frontend/.gitignore to include .env.local if not already:
       ```
       # Logs
       logs
       *.log
       npm-debug.log*

       # Dependencies
       node_modules
       .pnpm-store

       # Build
       dist
       dist-ssr
       *.local

       # Editor
       .vscode/*
       !.vscode/extensions.json
       .idea

       # Environment
       .env.local
       .env.*.local

       # OS
       .DS_Store
       Thumbs.db
       ```

    4. Create frontend/src/lib/api-client.ts:
       ```typescript
       const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000'

       /**
        * Custom error class for API errors with status code and detail message.
        * Normalizes error responses from the FastAPI backend.
        */
       export class ApiError extends Error {
         constructor(
           public status: number,
           public detail: string,
           public originalError?: unknown
         ) {
           super(detail)
           this.name = 'ApiError'
         }

         /**
          * Check if error is a client error (4xx)
          */
         isClientError(): boolean {
           return this.status >= 400 && this.status < 500
         }

         /**
          * Check if error is a server error (5xx)
          */
         isServerError(): boolean {
           return this.status >= 500
         }

         /**
          * Check if error is retryable (network error or 5xx)
          */
         isRetryable(): boolean {
           return this.status === 0 || this.isServerError()
         }
       }

       /**
        * Options for the API client
        */
       interface ApiClientOptions extends Omit<RequestInit, 'body'> {
         body?: unknown
       }

       /**
        * Typed fetch wrapper with error handling.
        * Automatically handles JSON serialization and error normalization.
        *
        * @param endpoint - API endpoint (without base URL), e.g., '/chat' or '/sessions/123'
        * @param options - Fetch options with typed body
        * @returns Promise resolving to typed response data
        * @throws ApiError on non-2xx responses or network errors
        *
        * @example
        * // GET request
        * const sessions = await apiClient<SessionsResponse>('/sessions')
        *
        * @example
        * // POST request
        * const response = await apiClient<ChatResponse>('/chat', {
        *   method: 'POST',
        *   body: { message: 'Hello', session_id: null }
        * })
        */
       export async function apiClient<T>(
         endpoint: string,
         options: ApiClientOptions = {}
       ): Promise<T> {
         const { body, headers, ...restOptions } = options
         const url = `${API_BASE_URL}${endpoint}`

         try {
           const response = await fetch(url, {
             ...restOptions,
             headers: {
               'Content-Type': 'application/json',
               ...headers,
             },
             body: body ? JSON.stringify(body) : undefined,
           })

           if (!response.ok) {
             let detail = 'Unknown error'
             try {
               const errorData = await response.json()
               // FastAPI returns errors as { detail: string } or { detail: [...] }
               if (typeof errorData.detail === 'string') {
                 detail = errorData.detail
               } else if (Array.isArray(errorData.detail)) {
                 // Validation errors come as array
                 detail = errorData.detail.map((e: { msg: string }) => e.msg).join(', ')
               } else {
                 detail = JSON.stringify(errorData)
               }
             } catch {
               detail = response.statusText || `HTTP ${response.status}`
             }
             throw new ApiError(response.status, detail)
           }

           // Handle empty responses (204 No Content)
           if (response.status === 204) {
             return undefined as T
           }

           return response.json()
         } catch (error) {
           // Re-throw ApiError as-is
           if (error instanceof ApiError) {
             throw error
           }

           // Network errors (fetch failed)
           if (error instanceof TypeError && error.message.includes('fetch')) {
             throw new ApiError(0, 'Network error: Unable to connect to server', error)
           }

           // Unknown errors
           throw new ApiError(0, 'An unexpected error occurred', error)
         }
       }

       /**
        * Helper to construct query strings from an object
        */
       export function buildQueryString(params: Record<string, string | number | boolean | undefined>): string {
         const searchParams = new URLSearchParams()
         for (const [key, value] of Object.entries(params)) {
           if (value !== undefined) {
             searchParams.append(key, String(value))
           }
         }
         const queryString = searchParams.toString()
         return queryString ? `?${queryString}` : ''
       }
       ```

    Key implementation details:
    - Uses native fetch (no external HTTP library needed for this scope)
    - ApiError class normalizes all error responses
    - Handles FastAPI validation error format (array of detail objects)
    - Network errors caught and converted to ApiError with status 0
    - buildQueryString helper for constructing URL params
  </action>
  <verify>
    Check that frontend/src/lib/api-client.ts exists and exports apiClient and ApiError.
    Check that frontend/.env.example exists.
    Check that frontend/.env.local exists (or create it).
    Run `cd frontend && pnpm tsc --noEmit` - no type errors.
  </verify>
  <done>
    API client created with typed fetch wrapper, ApiError class, error handling for FastAPI responses, and environment variable configuration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure TanStack Query and create API types</name>
  <files>
    frontend/src/lib/query-client.ts
    frontend/src/types/api.ts
  </files>
  <action>
    Set up TanStack Query and define TypeScript types:

    1. Create frontend/src/lib/query-client.ts:
       ```typescript
       import { QueryClient } from '@tanstack/react-query'

       /**
        * Global QueryClient configuration.
        *
        * Settings:
        * - staleTime: 1 minute - data considered fresh for 1 min before background refetch
        * - gcTime: 5 minutes - unused cached data kept for 5 min (formerly cacheTime)
        * - retry: 1 - retry failed requests once
        * - refetchOnWindowFocus: false - don't refetch when user returns to tab
        */
       export const queryClient = new QueryClient({
         defaultOptions: {
           queries: {
             staleTime: 1000 * 60, // 1 minute
             gcTime: 1000 * 60 * 5, // 5 minutes
             retry: 1,
             refetchOnWindowFocus: false,
           },
           mutations: {
             retry: 0, // Don't retry mutations by default
           },
         },
       })
       ```

    2. Create frontend/src/types/api.ts with types matching the backend schemas:
       ```typescript
       /**
        * API types matching FastAPI backend Pydantic schemas.
        * Source: src/posts/schemas.py, src/sessions/schemas.py,
        *         src/distributed_task/schemas.py, src/evaluation/schemas.py
        */

       // ============================================
       // Chat & Sessions
       // ============================================

       export interface ChatRequest {
         message: string
         session_id?: string | null
         metadata?: Record<string, unknown>
       }

       export interface ChatResponse {
         message: string
         session_id: string
         sources: string[]
         timestamp: string
         metadata?: Record<string, unknown>
       }

       export interface Message {
         role: 'user' | 'assistant'
         content: string
         timestamp: string
         sources?: string[]
       }

       export interface Session {
         session_id: string
         messages: Message[]
         created_at: string
         updated_at: string
         metadata?: Record<string, unknown>
       }

       export interface SessionsListResponse {
         sessions: Session[]
       }

       // ============================================
       // Retrieval
       // ============================================

       export type PipelineType = 'recursive_overlap' | 'semantic'

       export interface RetrievalRequest {
         query: string
         top_k?: number
         use_query_enhancer?: boolean
         use_reranking?: boolean
         pipeline_type?: PipelineType
       }

       export interface RetrievedDocument {
         text: string
         source: string
         score: number | null
         metadata: Record<string, unknown>
       }

       export interface RetrievalResponse {
         query: string
         documents: RetrievedDocument[]
         total_retrieved: number
       }

       // ============================================
       // Ingestion
       // ============================================

       export type IngestionStatus =
         | 'pending'
         | 'processing'
         | 'chunking'
         | 'indexing'
         | 'completed'
         | 'failed'

       export interface IngestionJobRequest {
         folder_path: string
         file_types?: string[]
         pipeline_type?: PipelineType
       }

       export interface IngestionJobResponse {
         job_id: string
         status: string
         message: string
       }

       export interface TaskProgress {
         job_id: string
         status: IngestionStatus
         total_documents?: number
         processed_documents?: number
         successful_documents?: number
         failed_documents?: number
         documents_left?: number
         current_file?: string
         estimated_time_remaining_seconds?: number
         progress_percentage?: number
         error_message?: string
         total_time_seconds?: number
       }

       export interface AssetFolder {
         name: string
         path: string
         file_count?: number
       }

       export interface AssetsListResponse {
         folders: AssetFolder[]
       }

       // ============================================
       // Evaluation
       // ============================================

       export interface EvaluationRequest {
         folder_path: string
         top_k?: number
         use_query_enhancer?: boolean
         use_reranking?: boolean
         num_questions_per_doc?: number
         source_evaluation_id?: string | null
         question_group_id?: string | null
       }

       export interface EvaluationStartResponse {
         evaluation_id: string
         question_group_id: string
         status: string
         message: string
       }

       export interface EvaluationResultsSummary {
         hit_rate?: number
         mrr?: number
         avg_score?: number
         total_questions?: number
       }

       export interface EvaluationStatusResponse {
         evaluation_id: string
         question_group_id: string
         status: string
         folder_path: string
         retrieve_params: Record<string, unknown>
         num_documents_processed: number
         created_at: string
         completed_at?: string
         results_summary?: EvaluationResultsSummary
         error_message?: string
         related_evaluation_ids: string[]
       }

       export interface EvaluationsListResponse {
         evaluations: EvaluationStatusResponse[]
       }

       // ============================================
       // Common
       // ============================================

       /**
        * Generic API error response from FastAPI
        */
       export interface ApiErrorResponse {
         detail: string | Array<{ loc: string[]; msg: string; type: string }>
       }
       ```

    Types are derived from:
    - src/posts/schemas.py - RetrievalRequest, RetrievalResponse
    - src/sessions/schemas.py - Session, Message types
    - src/distributed_task/schemas.py - TaskProgress, IngestionJob types
    - src/evaluation/schemas.py - EvaluationStatusResponse types
  </action>
  <verify>
    Check that frontend/src/lib/query-client.ts exports queryClient.
    Check that frontend/src/types/api.ts exports all type definitions.
    Run `cd frontend && pnpm tsc --noEmit` - no type errors.
  </verify>
  <done>
    TanStack Query client configured with appropriate defaults, and all API types defined matching the FastAPI backend schemas.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate TanStack Query into App with DevTools</name>
  <files>
    frontend/src/App.tsx
  </files>
  <action>
    Update App.tsx to include TanStack Query provider:

    1. Read the current App.tsx (from Plan 02, has ThemeProvider and layout)

    2. Update frontend/src/App.tsx to wrap with QueryClientProvider:
       ```typescript
       import { useState } from "react"
       import { QueryClientProvider } from "@tanstack/react-query"
       import { ReactQueryDevtools } from "@tanstack/react-query-devtools"
       import { ThemeProvider } from "@/providers/theme-provider"
       import { SidebarProvider } from "@/components/ui/sidebar"
       import { AppSidebar } from "@/components/layout/app-sidebar"
       import { Header } from "@/components/layout/header"
       import { ChatPage } from "@/features/chat/ChatPage"
       import { RetrievalPage } from "@/features/retrieval/RetrievalPage"
       import { IngestionPage } from "@/features/ingestion/IngestionPage"
       import { EvaluationPage } from "@/features/evaluation/EvaluationPage"
       import { Toaster } from "@/components/ui/sonner"
       import { queryClient } from "@/lib/query-client"

       function AppContent() {
         const [activeSection, setActiveSection] = useState("chat")

         const renderPage = () => {
           switch (activeSection) {
             case "chat":
               return <ChatPage />
             case "retrieval":
               return <RetrievalPage />
             case "ingestion":
               return <IngestionPage />
             case "evaluation":
               return <EvaluationPage />
             default:
               return <ChatPage />
           }
         }

         return (
           <SidebarProvider>
             <div className="flex min-h-screen w-full">
               <AppSidebar
                 activeSection={activeSection}
                 onSectionChange={setActiveSection}
               />
               <div className="flex flex-1 flex-col">
                 <Header />
                 {renderPage()}
               </div>
             </div>
             <Toaster position="bottom-right" />
           </SidebarProvider>
         )
       }

       function App() {
         return (
           <QueryClientProvider client={queryClient}>
             <ThemeProvider defaultTheme="system" storageKey="vite-ui-theme">
               <AppContent />
             </ThemeProvider>
             <ReactQueryDevtools initialIsOpen={false} />
           </QueryClientProvider>
         )
       }

       export default App
       ```

    Key integration points:
    - QueryClientProvider is the outermost provider (standard pattern)
    - ReactQueryDevtools placed inside QueryClientProvider but outside ThemeProvider
    - DevTools set to initialIsOpen={false} - click flower icon in bottom-right to open
    - DevTools automatically excluded from production builds
  </action>
  <verify>
    Run `cd frontend && pnpm dev` and verify:
    1. App loads without errors
    2. React Query DevTools flower icon appears in bottom-right corner
    3. Click DevTools icon - panel opens showing query cache (empty initially)
    4. Theme toggle still works
    5. Navigation still works

    Run `cd frontend && pnpm tsc --noEmit` - no type errors
    Run `cd frontend && pnpm build` - builds successfully (DevTools excluded in prod)
  </verify>
  <done>
    TanStack Query integrated into App with DevTools available in development mode. Application builds successfully for production.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **API Client Test (manual verification):**
   Open browser console and test (note: backend must be running):
   ```javascript
   // This will fail with network error if backend not running - that's expected
   // The point is the error handling works correctly
   fetch('http://localhost:8000/sessions').then(r => r.json()).then(console.log)
   ```

2. **TypeScript Verification:**
   ```bash
   cd frontend && pnpm tsc --noEmit
   ```
   All types should compile without errors.

3. **Build Verification:**
   ```bash
   cd frontend && pnpm build
   ```
   Production build should complete without errors. DevTools not included.

4. **DevTools Verification:**
   - Run `pnpm dev`
   - Look for flower/plant icon in bottom-right corner
   - Click it - DevTools panel should open
   - Shows "No queries" initially (expected - no data fetching yet)

5. **Environment Variable Test:**
   - Check .env.local has VITE_API_URL=http://localhost:8000
   - In browser console: `import.meta.env.VITE_API_URL` should show the URL
</verification>

<success_criteria>
- FOUN-07: API client configured with typed fetch and error handling (apiClient function with ApiError class works)
- FOUN-08: TanStack Query configured for server state management (QueryClientProvider wraps app, DevTools visible)
- All API types defined matching backend schemas
- Environment variable configuration in place
- Production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md` using the summary template.
</output>
