---
phase: 03-retrieval-testing
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - frontend/src/features/retrieval/components/ResultRow.tsx
  - frontend/src/features/retrieval/components/ResultsTable.tsx
  - frontend/src/features/retrieval/components/ResultsSkeleton.tsx
  - frontend/src/features/retrieval/RetrievalPage.tsx
autonomous: true

must_haves:
  truths:
    - "User can see retrieval results in a table with score and source columns"
    - "User can expand a result row to view full text content"
    - "User sees loading skeleton while retrieval is in progress"
    - "User sees error message with retry button on failure"
    - "User sees empty state message when no results returned"
  artifacts:
    - path: "frontend/src/features/retrieval/components/ResultRow.tsx"
      provides: "Expandable result row component"
      exports: ["ResultRow"]
    - path: "frontend/src/features/retrieval/components/ResultsTable.tsx"
      provides: "Results table with expandable rows"
      exports: ["ResultsTable"]
    - path: "frontend/src/features/retrieval/components/ResultsSkeleton.tsx"
      provides: "Loading skeleton for table"
      exports: ["ResultsSkeleton"]
    - path: "frontend/src/features/retrieval/RetrievalPage.tsx"
      provides: "Complete retrieval testing page"
      exports: ["RetrievalPage"]
  key_links:
    - from: "frontend/src/features/retrieval/RetrievalPage.tsx"
      to: "useRetrieve"
      via: "hook call and mutation"
      pattern: "useRetrieve\\(\\)"
    - from: "frontend/src/features/retrieval/RetrievalPage.tsx"
      to: "RetrievalForm"
      via: "component with onSubmit"
      pattern: "<RetrievalForm"
    - from: "frontend/src/features/retrieval/RetrievalPage.tsx"
      to: "ResultsTable"
      via: "conditional render with data"
      pattern: "<ResultsTable"
    - from: "frontend/src/features/retrieval/components/ResultRow.tsx"
      to: "Collapsible"
      via: "expandable row pattern"
      pattern: "<Collapsible"
---

<objective>
Create the results display components (table, expandable rows, skeleton) and integrate everything into RetrievalPage with proper loading, error, and empty states.

Purpose: Complete the retrieval testing interface by adding the output side - results display with expansion.
Output: Fully functional retrieval testing page with form, results table, and all states.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-retrieval-testing/03-RESEARCH.md
@.planning/phases/03-retrieval-testing/03-01-SUMMARY.md

# Key existing files from Plan 01
@frontend/src/features/retrieval/hooks/useRetrieve.ts
@frontend/src/features/retrieval/components/RetrievalForm.tsx
@frontend/src/components/ui/table.tsx
@frontend/src/components/ui/collapsible.tsx
@frontend/src/types/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ResultRow component with expandable content</name>
  <files>
    frontend/src/features/retrieval/components/ResultRow.tsx
  </files>
  <action>
    Create ResultRow.tsx with Collapsible pattern for expandable rows:

    ```typescript
    import { useState } from 'react'
    import { ChevronDown } from 'lucide-react'
    import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible'
    import { TableCell, TableRow } from '@/components/ui/table'
    import { cn } from '@/lib/utils'
    import type { RetrievedDocument } from '@/types/api'

    interface ResultRowProps {
      document: RetrievedDocument
      index: number
    }

    export function ResultRow({ document, index }: ResultRowProps) {
      const [isOpen, setIsOpen] = useState(false)

      // Truncate text for preview (first 100 chars)
      const previewText = document.text.length > 100
        ? document.text.slice(0, 100) + '...'
        : document.text

      // Format score safely (can be null when reranking not used)
      const scoreDisplay = document.score?.toFixed(4) ?? 'N/A'

      return (
        <Collapsible open={isOpen} onOpenChange={setIsOpen} asChild>
          <>
            <CollapsibleTrigger asChild>
              <TableRow
                className="cursor-pointer hover:bg-muted/50"
                onClick={() => setIsOpen(!isOpen)}
              >
                <TableCell className="w-12 font-medium">{index + 1}</TableCell>
                <TableCell className="max-w-md">
                  <span className="truncate block">{previewText}</span>
                </TableCell>
                <TableCell className="max-w-32">
                  <span className="truncate block">{document.source}</span>
                </TableCell>
                <TableCell className="text-right">{scoreDisplay}</TableCell>
                <TableCell className="w-10">
                  <ChevronDown
                    className={cn(
                      'h-4 w-4 transition-transform duration-200',
                      isOpen && 'rotate-180'
                    )}
                  />
                </TableCell>
              </TableRow>
            </CollapsibleTrigger>
            <CollapsibleContent asChild>
              <TableRow className="hover:bg-transparent">
                <TableCell colSpan={5} className="bg-muted/30 p-4">
                  <div className="space-y-3">
                    <div>
                      <p className="text-sm font-medium mb-1">Full Text:</p>
                      <p className="text-sm whitespace-pre-wrap">{document.text}</p>
                    </div>
                    {Object.keys(document.metadata).length > 0 && (
                      <div>
                        <p className="text-sm font-medium mb-1">Metadata:</p>
                        <pre className="text-xs bg-muted p-2 rounded overflow-x-auto">
                          {JSON.stringify(document.metadata, null, 2)}
                        </pre>
                      </div>
                    )}
                  </div>
                </TableCell>
              </TableRow>
            </CollapsibleContent>
          </>
        </Collapsible>
      )
    }
    ```

    Key patterns (from research):
    - Collapsible wraps both trigger row and content row with fragment
    - Use `asChild` on Collapsible to avoid extra wrapper
    - CollapsibleTrigger wraps TableRow with `asChild`
    - Chevron rotates 180 degrees when open
    - Safe score display with optional chaining and nullish coalescing
    - Text truncated in preview, full text in expanded section
    - Metadata shown as formatted JSON

    AVOID:
    - Do NOT remove asChild - causes invalid DOM nesting warnings
    - Do NOT use single score.toFixed() - score can be null
  </action>
  <verify>
    ```bash
    cd frontend && pnpm exec tsc --noEmit
    ```
    TypeScript compiles without errors.
  </verify>
  <done>ResultRow component created with expandable content (RETR-08)</done>
</task>

<task type="auto">
  <name>Task 2: Create ResultsTable and ResultsSkeleton components</name>
  <files>
    frontend/src/features/retrieval/components/ResultsTable.tsx
    frontend/src/features/retrieval/components/ResultsSkeleton.tsx
  </files>
  <action>
    Create ResultsTable.tsx:

    ```typescript
    import {
      Table,
      TableBody,
      TableHead,
      TableHeader,
      TableRow,
    } from '@/components/ui/table'
    import { ResultRow } from './ResultRow'
    import type { RetrievedDocument } from '@/types/api'

    interface ResultsTableProps {
      documents: RetrievedDocument[]
      query: string
      totalRetrieved: number
    }

    export function ResultsTable({ documents, query, totalRetrieved }: ResultsTableProps) {
      return (
        <div className="space-y-2">
          <div className="flex items-center justify-between text-sm text-muted-foreground">
            <span>Query: "{query}"</span>
            <span>{totalRetrieved} result{totalRetrieved !== 1 ? 's' : ''} found</span>
          </div>
          <div className="border rounded-lg">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-12">#</TableHead>
                  <TableHead>Text Preview</TableHead>
                  <TableHead>Source</TableHead>
                  <TableHead className="text-right">Score</TableHead>
                  <TableHead className="w-10"></TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {documents.map((document, index) => (
                  <ResultRow
                    key={`${document.source}-${index}`}
                    document={document}
                    index={index}
                  />
                ))}
              </TableBody>
            </Table>
          </div>
        </div>
      )
    }
    ```

    Create ResultsSkeleton.tsx:

    ```typescript
    import { Skeleton } from '@/components/ui/skeleton'
    import {
      Table,
      TableBody,
      TableCell,
      TableHead,
      TableHeader,
      TableRow,
    } from '@/components/ui/table'

    interface ResultsSkeletonProps {
      rows?: number
    }

    export function ResultsSkeleton({ rows = 5 }: ResultsSkeletonProps) {
      return (
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <Skeleton className="h-4 w-48" />
            <Skeleton className="h-4 w-24" />
          </div>
          <div className="border rounded-lg">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-12">#</TableHead>
                  <TableHead>Text Preview</TableHead>
                  <TableHead>Source</TableHead>
                  <TableHead className="text-right">Score</TableHead>
                  <TableHead className="w-10"></TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {Array.from({ length: rows }).map((_, i) => (
                  <TableRow key={i}>
                    <TableCell><Skeleton className="h-4 w-6" /></TableCell>
                    <TableCell><Skeleton className="h-4 w-full max-w-md" /></TableCell>
                    <TableCell><Skeleton className="h-4 w-24" /></TableCell>
                    <TableCell className="text-right"><Skeleton className="h-4 w-16 ml-auto" /></TableCell>
                    <TableCell><Skeleton className="h-4 w-4" /></TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        </div>
      )
    }
    ```

    Key patterns:
    - Table header is consistent between skeleton and results
    - Skeleton shows same structure as real table
    - ResultRow used for each document
    - Query and total count shown above table
  </action>
  <verify>
    ```bash
    cd frontend && pnpm exec tsc --noEmit
    ```
    TypeScript compiles without errors.
  </verify>
  <done>ResultsTable and ResultsSkeleton components created (RETR-07, RETR-09)</done>
</task>

<task type="auto">
  <name>Task 3: Integrate all components into RetrievalPage</name>
  <files>
    frontend/src/features/retrieval/RetrievalPage.tsx
  </files>
  <action>
    Replace the placeholder RetrievalPage with full implementation:

    ```typescript
    import { useRef } from 'react'
    import { Search, RefreshCw } from 'lucide-react'
    import { PageContainer } from '@/components/layout/page-container'
    import { Button } from '@/components/ui/button'
    import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
    import { RetrievalForm } from './components/RetrievalForm'
    import { ResultsTable } from './components/ResultsTable'
    import { ResultsSkeleton } from './components/ResultsSkeleton'
    import { useRetrieve } from './hooks/useRetrieve'
    import type { RetrievalRequest } from '@/types/api'

    export function RetrievalPage() {
      const lastRequestRef = useRef<RetrievalRequest | null>(null)

      const {
        mutate: retrieve,
        data,
        isPending,
        isError,
        error,
        reset,
      } = useRetrieve()

      const handleSubmit = (request: RetrievalRequest) => {
        lastRequestRef.current = request
        reset() // Clear previous error
        retrieve(request)
      }

      const handleRetry = () => {
        if (lastRequestRef.current) {
          reset()
          retrieve(lastRequestRef.current)
        }
      }

      return (
        <PageContainer>
          <div className="space-y-6">
            {/* Header */}
            <div>
              <h2 className="text-2xl font-semibold">Retrieval Testing</h2>
              <p className="text-muted-foreground">
                Test retrieval queries with different parameters and inspect results
              </p>
            </div>

            {/* Query Form Card */}
            <Card>
              <CardHeader>
                <CardTitle>Query Parameters</CardTitle>
                <CardDescription>
                  Configure your search query and retrieval options
                </CardDescription>
              </CardHeader>
              <CardContent>
                <RetrievalForm
                  onSubmit={handleSubmit}
                  isPending={isPending}
                />
              </CardContent>
            </Card>

            {/* Error State */}
            {isError && (
              <div className="border border-destructive/50 bg-destructive/10 rounded-lg p-4">
                <div className="flex items-center justify-between">
                  <p className="text-sm text-destructive">
                    Failed to retrieve: {error instanceof Error ? error.message : 'Unknown error'}
                  </p>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={handleRetry}
                    className="border-destructive/50 text-destructive hover:bg-destructive/10"
                  >
                    <RefreshCw className="h-3 w-3 mr-1" />
                    Retry
                  </Button>
                </div>
              </div>
            )}

            {/* Loading State */}
            {isPending && <ResultsSkeleton rows={5} />}

            {/* Results */}
            {data && !isPending && (
              data.documents.length > 0 ? (
                <ResultsTable
                  documents={data.documents}
                  query={data.query}
                  totalRetrieved={data.total_retrieved}
                />
              ) : (
                <div className="text-center py-12 text-muted-foreground">
                  <Search className="h-12 w-12 mx-auto mb-4 opacity-50" />
                  <p className="text-lg font-medium">No results found</p>
                  <p className="text-sm">Try adjusting your query or parameters</p>
                </div>
              )
            )}
          </div>
        </PageContainer>
      )
    }
    ```

    Key patterns (from research):
    - useRef for lastRequest to enable retry without re-render
    - reset() called before new mutation to clear error state
    - Error banner styled consistently with ChatPage
    - Loading skeleton shown during isPending
    - Empty state with icon and helpful message
    - Results shown only when data exists and not pending
    - Card wrapper for form gives visual separation

    State flow:
    1. Initial: Just form visible
    2. Pending: Form disabled + skeleton visible
    3. Error: Form enabled + error banner with retry
    4. Success (results): Form enabled + results table
    5. Success (empty): Form enabled + empty state message
  </action>
  <verify>
    1. `cd frontend && pnpm build` - Build succeeds
    2. `cd frontend && pnpm dev` - Start dev server, verify:
       - Retrieval Testing page shows form with all controls
       - Slider shows current value
       - Checkboxes toggle correctly
       - Dropdown has both pipeline options
       - Button disabled when query empty
       - (If backend available) Submit shows skeleton then results
       - (If backend unavailable) Submit shows error with retry
  </verify>
  <done>
    RetrievalPage fully integrated with form, results table, loading skeleton, error state, and empty state (RETR-01 through RETR-10 complete)
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cd frontend && pnpm build` passes
2. Navigate to Retrieval Testing page in browser
3. Form shows: query input, Top-K slider with value, pipeline dropdown, two checkboxes, Retrieve button
4. Button is disabled when query is empty
5. Slider updates value display in real-time
6. (With backend) Submit retrieval and verify:
   - Skeleton shows during loading
   - Results table displays with expandable rows
   - Clicking row expands to show full text and metadata
   - Empty query returns helpful message
7. (Without backend) Verify error state shows with retry button
</verification>

<success_criteria>
- ResultRow with expandable content created
- ResultsTable and ResultsSkeleton components created
- RetrievalPage integrated with all components
- Loading, error, empty, and success states all work
- All RETR-* requirements (01-10) addressed
- Phase 3 complete and ready for verification
</success_criteria>

<output>
After completion, create `.planning/phases/03-retrieval-testing/03-02-SUMMARY.md`
</output>
