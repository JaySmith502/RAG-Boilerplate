---
phase: 02-chat
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - frontend/src/features/chat/hooks/useChatScroll.ts
  - frontend/src/features/chat/components/MessageBubble.tsx
  - frontend/src/features/chat/components/MessageList.tsx
  - frontend/src/features/chat/components/MessageInput.tsx
  - frontend/src/features/chat/ChatPage.tsx
autonomous: true

must_haves:
  truths:
    - "User can see messages in the chat area with visual distinction between user and assistant"
    - "User can type a message in the input area"
    - "User can send a message by clicking Send or pressing Enter"
    - "Input is cleared after successful message send"
    - "Chat auto-scrolls to newest message"
    - "Message timestamps are displayed"
  artifacts:
    - path: "frontend/src/features/chat/hooks/useChatScroll.ts"
      provides: "Auto-scroll behavior hook"
      exports: ["useChatScroll"]
    - path: "frontend/src/features/chat/components/MessageBubble.tsx"
      provides: "Individual message display"
      exports: ["MessageBubble"]
    - path: "frontend/src/features/chat/components/MessageList.tsx"
      provides: "Scrollable message list container"
      exports: ["MessageList"]
    - path: "frontend/src/features/chat/components/MessageInput.tsx"
      provides: "Message input with send button"
      exports: ["MessageInput"]
    - path: "frontend/src/features/chat/ChatPage.tsx"
      provides: "Complete chat page layout"
      min_lines: 50
  key_links:
    - from: "frontend/src/features/chat/ChatPage.tsx"
      to: "useSession"
      via: "hook call for loading messages"
      pattern: "useSession\\("
    - from: "frontend/src/features/chat/ChatPage.tsx"
      to: "useSendMessage"
      via: "hook call for sending"
      pattern: "useSendMessage\\(\\)"
    - from: "frontend/src/features/chat/components/MessageInput.tsx"
      to: "onSend callback"
      via: "form submission"
      pattern: "onSend\\("
---

<objective>
Build the core chat UI components: message bubbles with user/assistant distinction, scrollable message list with auto-scroll, and message input with Enter-to-send functionality.

Purpose: Deliver the primary chat experience where users can view and send messages.
Output: Fully functional chat interface with message display, input, and send capabilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chat/02-RESEARCH.md
@.planning/phases/02-chat/02-01-SUMMARY.md

# Key existing files
@frontend/src/features/chat/hooks/useSessions.ts
@frontend/src/features/chat/hooks/useSession.ts
@frontend/src/features/chat/hooks/useSendMessage.ts
@frontend/src/types/api.ts
@frontend/src/lib/utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auto-scroll hook and MessageBubble component</name>
  <files>
    frontend/src/features/chat/hooks/useChatScroll.ts
    frontend/src/features/chat/components/MessageBubble.tsx
  </files>
  <action>
    **useChatScroll.ts** - Smart auto-scroll that respects user scroll position:
    ```typescript
    import { useRef, useEffect, useCallback } from 'react'

    export function useChatScroll<T>(deps: T[]) {
      const containerRef = useRef<HTMLDivElement>(null)
      const isUserScrolledUp = useRef(false)

      const handleScroll = useCallback(() => {
        if (!containerRef.current) return
        const { scrollTop, scrollHeight, clientHeight } = containerRef.current
        // User is "at bottom" if within 100px of bottom
        isUserScrolledUp.current = scrollHeight - scrollTop - clientHeight > 100
      }, [])

      useEffect(() => {
        if (!containerRef.current || isUserScrolledUp.current) return
        containerRef.current.scrollTop = containerRef.current.scrollHeight
      }, deps)

      const scrollToBottom = useCallback(() => {
        if (containerRef.current) {
          containerRef.current.scrollTop = containerRef.current.scrollHeight
          isUserScrolledUp.current = false
        }
      }, [])

      return { containerRef, handleScroll, scrollToBottom }
    }
    ```

    **MessageBubble.tsx** - Individual message with user/assistant styling:
    ```typescript
    import { cn } from '@/lib/utils'
    import type { Message } from '@/types/api'

    interface MessageBubbleProps {
      message: Message
      isPending?: boolean
    }

    export function MessageBubble({ message, isPending }: MessageBubbleProps) {
      const isUser = message.role === 'user'

      const formatTimestamp = (timestamp: string) => {
        const date = new Date(timestamp)
        return date.toLocaleTimeString(undefined, {
          hour: '2-digit',
          minute: '2-digit',
        })
      }

      return (
        <div
          className={cn(
            'flex w-full',
            isUser ? 'justify-end' : 'justify-start'
          )}
        >
          <div
            className={cn(
              'max-w-[80%] rounded-2xl px-4 py-3',
              isUser
                ? 'bg-primary text-primary-foreground rounded-br-md'
                : 'bg-muted rounded-bl-md',
              isPending && 'opacity-70'
            )}
          >
            <p className="whitespace-pre-wrap break-words">{message.content}</p>
            <p
              className={cn(
                'text-xs mt-1',
                isUser ? 'text-primary-foreground/70' : 'text-muted-foreground'
              )}
            >
              {formatTimestamp(message.timestamp)}
            </p>
          </div>
        </div>
      )
    }
    ```

    Key design choices:
    - User messages: primary color, right-aligned, rounded-br-md for chat bubble effect
    - Assistant messages: muted background, left-aligned, rounded-bl-md
    - Timestamps below message content in smaller text
    - Max width 80% to prevent full-width messages
    - `whitespace-pre-wrap` preserves line breaks, `break-words` prevents overflow
  </action>
  <verify>
    ```bash
    cd frontend && pnpm exec tsc --noEmit
    ```
    TypeScript compiles without errors.
  </verify>
  <done>useChatScroll hook and MessageBubble component created with proper styling</done>
</task>

<task type="auto">
  <name>Task 2: Create MessageList and MessageInput components</name>
  <files>
    frontend/src/features/chat/components/MessageList.tsx
    frontend/src/features/chat/components/MessageInput.tsx
  </files>
  <action>
    **MessageList.tsx** - Scrollable container with auto-scroll:
    ```typescript
    import { ScrollArea } from '@/components/ui/scroll-area'
    import { MessageBubble } from './MessageBubble'
    import { useChatScroll } from '../hooks/useChatScroll'
    import type { Message } from '@/types/api'

    interface MessageListProps {
      messages: Message[]
      pendingMessage?: string | null
    }

    export function MessageList({ messages, pendingMessage }: MessageListProps) {
      const { containerRef, handleScroll } = useChatScroll([messages, pendingMessage])

      return (
        <ScrollArea className="flex-1 px-4">
          <div
            ref={containerRef}
            onScroll={handleScroll}
            className="flex flex-col gap-4 py-4"
          >
            {messages.length === 0 && !pendingMessage ? (
              <div className="flex flex-col items-center justify-center h-[300px] text-muted-foreground">
                <p className="text-lg font-medium">Start a conversation</p>
                <p className="text-sm">Type a message below to begin</p>
              </div>
            ) : (
              <>
                {messages.map((message, index) => (
                  <MessageBubble key={`${message.timestamp}-${index}`} message={message} />
                ))}
                {pendingMessage && (
                  <MessageBubble
                    message={{
                      role: 'user',
                      content: pendingMessage,
                      timestamp: new Date().toISOString(),
                    }}
                    isPending
                  />
                )}
              </>
            )}
          </div>
        </ScrollArea>
      )
    }
    ```

    **MessageInput.tsx** - Input with Enter to send, Shift+Enter for newline:
    ```typescript
    import { useState, useRef, useEffect } from 'react'
    import { Send } from 'lucide-react'
    import { Button } from '@/components/ui/button'
    import { Textarea } from '@/components/ui/textarea'
    import { cn } from '@/lib/utils'

    interface MessageInputProps {
      onSend: (message: string) => void
      disabled?: boolean
      placeholder?: string
    }

    export function MessageInput({
      onSend,
      disabled = false,
      placeholder = 'Type a message...',
    }: MessageInputProps) {
      const [message, setMessage] = useState('')
      const textareaRef = useRef<HTMLTextAreaElement>(null)

      // Auto-resize textarea
      useEffect(() => {
        const textarea = textareaRef.current
        if (textarea) {
          textarea.style.height = 'auto'
          textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`
        }
      }, [message])

      const handleSubmit = () => {
        const trimmed = message.trim()
        if (trimmed && !disabled) {
          onSend(trimmed)
          setMessage('')
        }
      }

      const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault()
          handleSubmit()
        }
        // Shift+Enter creates newline naturally (default behavior)
      }

      return (
        <div className="border-t bg-background p-4">
          <div className="flex gap-2 items-end max-w-4xl mx-auto">
            <Textarea
              ref={textareaRef}
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder={placeholder}
              disabled={disabled}
              className={cn(
                'min-h-[44px] max-h-[200px] resize-none',
                'focus-visible:ring-1'
              )}
              rows={1}
            />
            <Button
              onClick={handleSubmit}
              disabled={disabled || !message.trim()}
              size="icon"
              className="shrink-0 h-[44px] w-[44px]"
            >
              <Send className="h-4 w-4" />
              <span className="sr-only">Send message</span>
            </Button>
          </div>
          <p className="text-xs text-muted-foreground text-center mt-2">
            Press Enter to send, Shift+Enter for new line
          </p>
        </div>
      )
    }
    ```

    Key design choices:
    - Auto-resizing textarea (up to 200px max height)
    - Enter sends, Shift+Enter for newlines (standard chat pattern)
    - Disabled state when sending
    - Centered content with max-width for readability
    - Clear visual send button with icon
  </action>
  <verify>
    ```bash
    cd frontend && pnpm exec tsc --noEmit
    ```
    TypeScript compiles without errors.
  </verify>
  <done>MessageList and MessageInput components created with auto-scroll and Enter-to-send</done>
</task>

<task type="auto">
  <name>Task 3: Integrate components into ChatPage</name>
  <files>
    frontend/src/features/chat/ChatPage.tsx
  </files>
  <action>
    **ChatPage.tsx** - Complete chat interface:
    ```typescript
    import { useCallback, useEffect } from 'react'
    import { PageContainer } from '@/components/layout/page-container'
    import { Skeleton } from '@/components/ui/skeleton'
    import { MessageList } from './components/MessageList'
    import { MessageInput } from './components/MessageInput'
    import { useSession } from './hooks/useSession'
    import { useSendMessage } from './hooks/useSendMessage'

    interface ChatPageProps {
      selectedSessionId: string | null
      onSelectSession: (sessionId: string | null) => void
    }

    export function ChatPage({ selectedSessionId, onSelectSession }: ChatPageProps) {
      const {
        data: session,
        isLoading: isLoadingSession,
        isError: isSessionError,
      } = useSession(selectedSessionId)

      const {
        mutate: sendMessage,
        isPending: isSending,
        variables: pendingVariables,
      } = useSendMessage()

      // When a new session is created from sending a message, update selection
      const handleSend = useCallback(
        (message: string) => {
          sendMessage(
            {
              message,
              session_id: selectedSessionId,
            },
            {
              onSuccess: (data) => {
                // If this was a new chat (no session), update to the new session ID
                if (!selectedSessionId && data.session_id) {
                  onSelectSession(data.session_id)
                }
              },
            }
          )
        },
        [selectedSessionId, sendMessage, onSelectSession]
      )

      const messages = session?.messages ?? []
      const pendingMessage = isSending ? pendingVariables?.message : null

      // Loading state for existing session
      if (selectedSessionId && isLoadingSession) {
        return (
          <PageContainer fullWidth className="flex flex-col h-[calc(100vh-4rem)] p-0">
            <div className="flex-1 p-4 space-y-4">
              <Skeleton className="h-16 w-3/4" />
              <Skeleton className="h-16 w-1/2 ml-auto" />
              <Skeleton className="h-16 w-2/3" />
            </div>
            <div className="border-t p-4">
              <Skeleton className="h-11 w-full" />
            </div>
          </PageContainer>
        )
      }

      // Error state
      if (selectedSessionId && isSessionError) {
        return (
          <PageContainer fullWidth className="flex flex-col h-[calc(100vh-4rem)] p-0">
            <div className="flex-1 flex items-center justify-center">
              <div className="text-center">
                <p className="text-lg font-medium text-destructive">Failed to load conversation</p>
                <p className="text-sm text-muted-foreground mt-1">Please try selecting another session</p>
              </div>
            </div>
          </PageContainer>
        )
      }

      return (
        <PageContainer fullWidth className="flex flex-col h-[calc(100vh-4rem)] p-0">
          <MessageList messages={messages} pendingMessage={pendingMessage} />
          <MessageInput onSend={handleSend} disabled={isSending} />
        </PageContainer>
      )
    }
    ```

    Key design choices:
    - Full height chat layout using `h-[calc(100vh-4rem)]` accounting for header
    - Optimistic UI: pending message shown immediately while waiting for API
    - Session auto-selection: when new chat gets a session_id from API, update state
    - Loading skeleton mimics chat message structure
    - Error state with clear message and guidance
    - `p-0` on container since MessageList and MessageInput handle their own padding
  </action>
  <verify>
    1. `cd frontend && pnpm build` - Build succeeds
    2. `cd frontend && pnpm dev` - Start dev server, verify:
       - New chat shows empty state with "Start a conversation" message
       - Can type message in input
       - Pressing Enter sends message (or click Send button)
       - Optimistic UI shows pending message immediately
       - After response, message list updates
       - Selecting existing session loads and displays messages
       - Loading skeleton appears while session loads
  </verify>
  <done>
    ChatPage integrates all components. Users can view messages, type, and send. Input clears after send. Auto-scroll works. Loading and error states display correctly.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `cd frontend && pnpm build` passes
2. New chat flow:
   - Empty state visible
   - Type message, press Enter
   - Message appears (pending state)
   - Response appears with assistant styling
3. Existing session flow:
   - Select session from sidebar
   - Messages load with loading skeleton
   - Full conversation visible with timestamps
4. User/assistant messages visually distinct (alignment, colors)
5. Auto-scroll works when at bottom, respects user scroll position when scrolled up
</verification>

<success_criteria>
- MessageBubble displays messages with role distinction and timestamps
- MessageList renders messages with auto-scroll
- MessageInput handles Enter-to-send and Shift+Enter for newlines
- ChatPage integrates all components with TanStack Query hooks
- Requirements addressed: CHAT-04, CHAT-05, CHAT-06, CHAT-07, CHAT-08, CHAT-11 (loading state partial)
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat/02-02-SUMMARY.md`
</output>
